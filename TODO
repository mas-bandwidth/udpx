DONE

	Sketch out the session token

	Sketch out connect data

	Add tests for read and write session token, encrypt/decrypt etc.

	Add tests for connect data

	Write function to generate connect token, inputs are gateway address, gateway public key. generates random session id.

	Create a tool to generate a connect token and print it out to stdout as base64

	How to pass the connect token from the tool into dev-client when it runs?

	Make shell command will do it.

	Whoops, connect data also needs public/private keypair.

	Can't just generate a random session id, it must be one half of a keypair, by design.

	Client now has connect token passed in via env var.

	Read in the env var, and then base64 decode and check the size of the byte array.

	Client needs to read the gateway address, gateway public key and session id from the connect token passed in.

	Client should extract and store the session token from the connect token.

	Now the client should connect as usual...

	Confirmed.

TODO

	---------------

	Extend core.go packet definition to include the session token in the prefix, after the chonkle.

	Update client to include the session token in packets sent.

	Update client to read the session token in packets received.

	---------------

	Update gateway to have session token in the payload packet on read and write.

	Server does not need to see or know about the session token for now, keep it at the gateway level (like the chonkle).

	Gateway decrypts the session token

	If the session token doesn't decrypt, drop the packet

	If the session token has expired, drop the packet.

	If the session token session id does not match the packet session id, drop the packet.

	---------------

	At this point the client should connect, have 20 seconds of grace, and then the gateway will drop all packets because the session token has expired.

	---------------

	Implement a new backend service "auth". 

	Its job is to generate connect tokens when asked, and to extend session tokens while a session is connected.

	The backend is presumed to talk to auth to get the initial connect token.

	The gateway talks to auth to extend the session token +10 seconds.

	The clients don't talk directly to this system. It's a private system the backend uses.

	The gateway needs a goroutine per-session entry. If the goroutine is nil, and <= 10 seconds remaining until expiry, create a goroutine that does the session extension.

	Use a channel to get the updated token back.

	Once the token comes back, copy it to the session entry, then send it back down to the client in the payload packets.

	---------------

	On the client, if the session token in received valid packets is more recent than the current one (might need a 64bit sequence number per-session token, eg. every 10 secs?), then update the session token stored locally that will be sent up to the gateway with each packet sent.

	---------------

	At this point we should have a system where connect tokens are the only way to connect to the server, and the sessions may only stay active as long as the session manager continues to renew them.

	Pretty badass.

	---------------

	Extend the connect data and session token to include the up/down bandwidth envelope in kbps.

	---------------

	Enforce this bandwidth envelope on the client via choke.

	---------------

	Enforce this bandwidth envelope on the gateway via dropping any additional packets above the envelope.

	---------------

	Enforce this bandwidth envelope on the server via choke.

	---------------