DONE

	Add packet types:

		0: payload
		1: challenge
		2. challenge response

	Add packet type to client -> gateway packet

	Handle the payload packet type by forwarding to server (todo, check for establish session w. gateway first...)

	Add session map with double buffered idea for automatic timeouts

	Initially, insert into session map without challenge/response, just to make sure that the idea works

	Server sends challenge packet to client, if no session entry for payload packet.

	Prefix the hack payload packet down from server to have first byte "core.PayloadPacket" (0)

	Check for this on the client, and handle the packet type in the recv, either payload, or challenge...

	Sketch out the flow with challenge and response packets

	Client should ignore packets that don't come from the gateway address.

	Hack up something suuuuuuper dirty just to get the challenge/response flow going...

	Gateway seems to not be correctly picking up the different packet types. What's up?

	Fixed it, bad index.

	-------------

	OK. Next step is definitely to include the challenge response in the regular payload packet.

	Since I have intentionally limited only large packets, firing out specific small packets from client -> gateway is not an option.

	thus, it must be included in the client to server packet.

	Suggest, a byte, is it included, and if so, include the challenge response.

	Implies the client should timeout or remomve the challenge response data, once it connects with the server (and then it will be tripped on again, as needed, when it receives a challenge packet).

	-------------

	In order to do the above, definitely need to do this on main thread.

	So we need the recv packet -> channel pipeline going.

	-------------
	
	Setup the channel for the main thread to process received packets from the goroutine.

	-------------

	Handle payload and challenge packets appropriately when dequeing them from the goroutine.

	-------------

TODO

	-------------

	Implement challenge token and add unit tests for it

	Challenge token should be encrypted (not readable by client) and have:

		timestamp 
		client address + port
		gateway address + port

	-------------

	The challenge packet should include the sequence that the challenge token was generated at, so the client can decide if the challenge packet is newer and update it.

	-------------

	Hook up the challenge token in the challenge/response protocol.

	This means including it in the challenge packet, and including the challenge token (encrypted) in the payload packet when it is set on the client.

	Once the client receives a payload packet from the server, with sequence > than the challenge seqeuence **IMPORTANT***

	Then the client may clear the challenge token.

	-------------
