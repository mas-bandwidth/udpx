DONE

	Add a mutex to protect the session token on the client. We can't write to and read from it from different threads.

TODO

	---------------

	Add mutex on client around gateway id

	---------------

	Add mutex on client around server id

	---------------

	Now the client should only update the session token if it is newer.

	To establish newness, we need a 64bit sequence number riding along with each session token.

	When a new session token comes along, the client updates to it, and updates its own session token sequence.

	The client also sets an expire time for the session token at initially 20 seconds (connect), and then subsequently 10 seconds after each session token update.

	When the client detects that the session token has expired, the client times out and prints "disconnected" before exiting.

	---------------

	Gateway needs some protection so it doesn't hammer auth for a connect token every packet received.

	There needs to be an enforced delay between subsequent update token requests.

	This can be added by putting in a "TokenUpdateCooldownTime", and putting it 1 sec in future, after each request comes back.

	---------------

	Check to see if we should be creating http transport instances in the goroutine, or having shared versions of that.

	Reduce timeout to 1 sec.

	Verify that retries happen.

	Track the retries, and print them out numbered.

	Don't run auth, and verify that the retries kick in once per-second until session token times out.

	---------------

























	---------------

	Extend the connect data and session token to include the up/down bandwidth envelope in kbps.

	---------------

	Enforce this bandwidth envelope on the client via choke.

	---------------

	Enforce this bandwidth envelope on the gateway via dropping any additional packets above the envelope.

	---------------

	Enforce this bandwidth envelope on the server via choke.

	---------------
