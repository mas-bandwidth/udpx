DONE

	Server needs a session entry structure.

	Same new/old swap as before.

	Store the *server* send sequence in the session id.

	*** exposure. if somebody reconnects as the same session but to a different gateway, and punches through again, the server may reset to zero sequence initially, which would expose nonce, therefore the session should carry along with it the most recently received sequence from the server, so a new entry can start there, and add like 100,000 to it.... ***

	^--- this will naturally fall from the "ack" bit sent up from the client

	Store the send and receive sequence in the server session map entry when it's created.

	Update the receive sequence when a packet is received.

	-------------

	We can't encrypt the packet that sends down the challenge response, since no session is established, we don't have send sequence numbers, and trying to fake this will break crypto by using the same nonce more than once.

	It seems that at best we can sign the challenge response packet.

	This may mean that we need to put the packet type as the first byte, instead of putting it after the seq/ack/ack_bits

	Need to think this through. Not sure what is best here yet...

	-------------

	What's clear is that at minimum, the challenge packet needs to have a different format to the payload packet.

	The challenge packet needs to be signed, or encrypted and signed, but in such a way that it doesn't depend on sequence numbers.

	The token itself is already encrypted, does it matter if another customer can take that token and try to reply with it? The token is specific to the address and session, and only that client knows the private key.

	-------------

	But what if somebody spoofs the server, and sends a challenge packet down to the client.

	The client will take the challenge, and include it in payload packets.

	The server will ignore it, however this makes it possible for an attacker to "stuff" a high sequence challenge, and block the ability of a client to migrate to another gateway or IP address.

	Therefore, I conclude that the challenge packet must be signed by the private key of the gateway, and verifiable using only the public key of the gateway.

	The public signed data also needs to include the sequence and the session id, so the client can verify that the challenge token corresponds to them, and that the challenge sequence isn't tampered with.

	-------------

	But if we sign the packet, then the gateway needs an additional private/public keypair just for signing, and this is undesirable.

	We could instead continue to encrypt the packet, but take advantage of the 24 byte nonce.

	For packet sequence numbers, we are only using the low 8 bytes of the nonce.

	By expanding to use the upper 16 bytes of the nonce, and setting the 63rd bit (top of uint64) to be true for the challenge token, then we can ensure that we have enough randomness (we only lose one bit), at the cost of reducing our sequence numbers effectively from 64bit to 63 bit.

	I find this frustrating because I'll have to write a spec, and this seems like a weird decision.

	Is there a better option?

	--------------

	No matter what is done, we need to move the packet type to the front of the packet for gateway -> client packets.

	--------------

	Change "hasChallengeToken" to be a uint8_t flags, and have bit 0 mean "challenge token".

	This way it can be used for other packet options, as needed.

	Much better for the spec.

	--------------

	OK, I've adjusted the payloads enough that I can now have an encrypted payload packet down from the gateway -> client, and a completely separate encryption scheme for the challenge packet.

	The next step is to encrypt via the 24 byte nonce, using bits above the 8 byte sequence to indicate things.

	I'll need to set the 64th bit (zero based) to one, in the nonce, to specify the server to client direction, and to zero, to specify the client -> server direction.

	That means that I could use the 65th bit (zero based) to indicate the nonce is for a challenge token.

	--------------

	Actually, this means that we'll need:

	2 bits in the the 9th byte of nonce.

	both bits 0 = client -> server packet
	first bit 1, second bit 0 = server -> client packet
	first bit 0, second bit 1 = challenge packet

	These values correspond to:

		0,1,2 in the first two bits. 3 is reserved.

	--------------

	OK client now has encrypted challenge token sent down to it.

	--------------

	Now the payload packet from gateway -> client needs to be encrypted

	--------------

	Client decryption is failing for payload packet. What's going on?

	Multiple issues, fixed the trivial ones, but the reason it's not working is because the session id passed down from server -> gateway is all zero bytes.

	--------------

	Track down how session id is getting lost on the server.

	Stupid error...

	--------------

	Client verify payload size and contents

	--------------


TODO

	--------------

	Expand the challenge packet to also have prefix and postfix.

	--------------

	Verify client packet filters pass for challenge packets.

	--------------

	Move as much the client packet filters pre-test to recv thread.

	--------------




















	-------------

	Server writes the same session id, sequence, ack, ack_bits, packet type header, but with the difference that we prefix the version and client address...

	eg. 

	[version][client address](standard header)(payload)

	This can be sent down to the gateway.

	-------------

	Extend the gateway to encrypt packet sent down to the client....

	Gateway encrypts payload packets.

	Gateway encrypts challenge packets.

	-------------

	Extend the client to decrypt the packets received from the gateway....

	Client decrypts payload packets.

	Client decrypts challenge packets.

	-------------

	Extend the client to ignore old packets by sequence.

	-------------

	Port across relay protection from reliable.io and test it.

	Extend the gateway to fully stop replay attacks via replay protection bitfield.

	-------------

	Port the reliability layer from reliable.io into golang and test it.

	-------------

	Hook up the reliability layer on the server-side.

	-------------

	Hook up the reliability layer on the client-side.

	-------------

	At this point we should have a functioning reliability layer between the client and server.

	-------------
