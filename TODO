DONE

	Server needs a session entry structure.

	Same new/old swap as before.

	Store the *server* send sequence in the session id.

	*** exposure. if somebody reconnects as the same session but to a different gateway, and punches through again, the server may reset to zero sequence initially, which would expose nonce, therefore the session should carry along with it the most recently received sequence from the server, so a new entry can start there, and add like 100,000 to it.... ***

	^--- this will naturally fall from the "ack" bit sent up from the client

	Store the send and receive sequence in the server session map entry when it's created.

	Update the receive sequence when a packet is received.

TODO

	-------------

	We can't encrypt the packet that sends down the challenge response, since no session is established, we don't have send sequence numbers, and trying to fake this will break crypto by using the same nonce more than once.

	It seems that at best we can sign the challenge response packet.

	This may mean that we need to put the packet type as the first byte, instead of putting it after the seq/ack/ack_bits

	Need to think this through. Not sure what is best here yet...

	-------------

	Server writes the same session id, sequence, ack, ack_bits, packet type header, but with the difference that we prefix the version and client address...

	eg. 

	[version][client address](standard header)(payload)

	This can be sent down to the gateway.

	-------------

	Extend the gateway to encrypt packet sent down to the client....

	Gateway encrypts payload packets.

	Gateway encrypts challenge packets.

	-------------

	Extend the client to decrypt the packets received from the gateway....

	Client decrypts payload packets.

	Client decrypts challenge packets.

	-------------

	Extend the client to ignore old packets by sequence.

	-------------

	Port across relay protection from reliable.io and test it.

	Extend the gateway to fully stop replay attacks via replay protection bitfield.

	-------------

	Port the reliability layer from reliable.io into golang and test it.

	-------------

	Hook up the reliability layer on the server-side.

	-------------

	Hook up the reliability layer on the client-side.

	-------------

	At this point we should have a functioning reliability layer between the client and server.

	-------------
