DONE

	Sketch out the session token

	Sketch out connect data

	Add tests for read and write session token, encrypt/decrypt etc.

	Add tests for connect data

	Write function to generate connect token, inputs are gateway address, gateway public key. generates random session id.

	Create a tool to generate a connect token and print it out to stdout as base64

	How to pass the connect token from the tool into dev-client when it runs?

	Make shell command will do it.

TODO

	Whoops, connect data also needs public/private keypair.

	Can't just generate a random session id, it must be one half of a keypair, by design.

	I'm not sure I want the backend generating the ephemeral client keypair. That seems wrong.

	---------------

	Client now has connect token passed in via env var.

	Read in the env var, and then base64 decode and check the size of the byte array.

	Client needs to read the gateway address, gateway public key and session id from the connect token passed in.

	Client should extract and store the session token from the connect token.

	Now the client should connect as usual...

	---------------

	Extend core.go packet definition to include the session token in the prefix, after the chonkle.

	Update client to include the session token in packets sent.

	Update client to include the session token in packets received.

	---------------

	Update gateway to have session token in the payload packet on read and write.

	Server does not need to see or know about the session token for now, keep it at the gateway level (like the chonkle).

	Gateway decrypts the session token

	If the session token doesn't decrypt, drop the packet

	If the session token has expired, drop the packet.

	If the session token session id does not match the packet session id, drop the packet.

	If there is <= 10 seconds remaining until the session token expires, and the

	---------------

	Implement a new backend service "session_manager". Its job is to renew sessions when asked (extend them to expire 10 seconds in the future).

	The clients don't talk directly to this system, the gateway talks to the session manager and does this.

	The gateway needs a goroutine per-session entry. If the goroutine is nil, and <= 10 seconds remaining until expiry, create a goroutine that does the 

	Use a channel to get the updated token back.

	Once the token comes back, copy it to the session entry, then send it back down to the client in the payload packets.

	---------------

	On the client, if the session token in received valid packets is more recent than the current one (might need a 64bit sequence number per-session token, eg. every 10 secs?), then update the session token stored locally that will be sent up to the gateway with each packet sent.

	---------------

	At this point we should have a system where connect tokens are the only way to connect to the server, and the sessions may only stay active as long as the session manager continues to renew them.

	Pretty badass.

	---------------
