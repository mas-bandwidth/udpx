DONE

	Implement secret box primitives and write tests for them

	Sketch out challenge token contents

	Implement read/write challenge token

	Implement write encrypted challenge token

	Implement test for read/write challenge token

	Implement read encrypted challenge token

	Implement tests for read/write encrypted challenge token

	Include an encrypted challenge token in the challenge packet

	Write the challenge sequence number after the challenge token, since the client needs this too

	Client reads the challenge token in the challenge packet when received, and the sequence number of the challenge.

	If the client has no challenge token stored, OR, the challenge token has higher sequence number that the current challenge, the client stores the challenge token + sequence number as current.

	When the client sends a payload packet to the gateway, if a challenge token exists, include it in the packet

	If no challenge token exists on the client, write a zero byte "no challenge token" at a point in the payload packet.

	Update the gateway to look for the challenge token in the payload packet

	If no session entry exists, but the challenge token exists, add the session map entry and pass the payload packet through to the server.

	Verify the client punches through challenge/response and gets payload packets in return.

	Verify the client stops sending challenge responses once it punches through.

	When the client receives a payload packet back from the server clear the challenge token.

TODO

	-------------

	Actually decrypt and verify the challenge token

	-------------

	Cleanly strip out the challenge token before forwarding the payload to the server.

	-------------

	Validate the payload on the server, to make sure it's not subtly fucked up.

	-------------

	Standardize packets sent from gateway -> client to have the same packet structure as client -> gateway packets.

	-------------
