IDEAS

	------------

	Start with the connect token.

	In this we need to have the following data, encrypted with the backend private key, and readable only by the gateways, even though this data will be passed down to the client:

		1. User id
		2. Session id
		3. Expiry (20 seconds into the future)

	This encrypted part, I will call the session token.

	The encrypted portion is part of a larger block of data called a connect token.

	The connect token starts with regular data that isn't encrypted, and then has the encrypted session token at the end.

	[connect token] = [connect data] [encrypted session token]

	The connect data is not encrypted, the client needs it in order to connect to the gateway:

		1. Session id
		2. Gateway address
		3. Gateway public key

	The connect data doesn't need to be signed. If the client or anybody else modifies it, it doesn't help them any.

	The actual token that goes into the packet is just the encrypted "session token" part.

	Every 10 seconds, the gateway is responsible for updating the session token on behalf of the session, and returning a new token extended for another 10 seconds.

	This new token is then returned down to the client.

	The gateway checks the token with each packet that comes in from a client.

	If the token is not valid, or is expired, the gateway ignores the packet completely.

	If the token decrypts, but the user id inside the session token is banned, the gateway ignores the packet completely.

	This way we can have a very secure system.

	------------

	There should be a globally unique concept of user id (32 bytes), such that specific user ids can be banned and scrubbed at the gateway level.

	The client should never know their unique client id. The user id is not PIAA. It is an internal implementation detail in our system.

	Thus, the unique client id should be encoded in the session token and not be readable by the client.

	------------

	The client should have the concept of choke on packets it sends, such that it respects the up kpbs limit.

	There should be a kilobits up/down limit per-session and the gateway should enforce this.

	The session token should contain the kilobits/sec limits. The client and gateway must be able to read these, but not modify them, thus they should be signed but not encrypted.

	------------

	There should be a connect token which turns into a session token that renews every 10 seconds. This should be done by the server, although the initial connect token must be generated to enable client connection.

	The gateway must scrub out any invalid or stale session tokens.

	Each session token has an expiry, eg. buy 20 seconds, extend 10 seconds w. 10 seconds grace.

	------------

	There should be key rotation such that the connect tokens and session tokens can be generated by a rotating key pair, such that if a keypair is leaked, it can easily be rotated out to a new one.

	------------

	There needs to be a system running behind gateways and servers that they can use to get the list of banned user ids, latest public keys and magic values, renew session tokens etc.

	-------------

	The job of the gateway is to:

		a) scrub packets that don't belong to our protocol

		b) scrub old packets that can't possibly be valid (eg. packets older than n sequence from current)

		c) verify signature and decrypt packets before passing on to the server

		d) maintain challenge/response protocols with the client

		e) handle migrations of clients from one IP:port to another

		f) handle migrations of clients from one gateway instance to another (via hashing or whatever)

	*** DONE ***

	-------------

	The job of the server is to:

		a) maintain reliability via ack/ack_bits

		b) enable migration of a client from one server instance to another

	*** DONE TO HERE ***

		c) queue up messages delivered from the client to some internal message processing system

		d) dequeue messages sent to the client and include them in payload packets sent down to the client at some regular send rate.

	-------------
	
	There should be a access token and a way for this token to be refreshed at some period, to maintain connectivity to the system.

	The gateway should just ignore any packets that don't have an up to date access token.

	Access tokens can just be included with every payload packet.

	Potentially, the client can avoid needing to update the access token entirely, if the server backend passes the updated token back down to the client every n seconds, this avoids the need to maintain additional connections.

	This is definitely desirable.

	-------------
